from .tile import *
from .room import Room
from .hallway import Hallway

class LevelGenerator:
	"""
	Generates a valid level board for the game snarl

	Level is generated by giving it a series of rooms and hallways, where each room is added first,
	ensuring that none overlap, and then each hallway is added, also ensuring no overlaps. After all
	rooms and hallways have been added, the level is generated as a nested list of Tiles.

	Parameters
	----------
	rooms : List[Room]
		Each room to be added to the level
	hallways : List[Hallway]
		Each hallway to be added to the level
	"""
	def __init__(self, level_json):
		self._rooms = []
		self._hallways = []
		self._max_width = 0
		self._max_height = 0
		self._whole_level = []
		# Add all given levels and rooms
		for room_json in level_json['rooms']:
			self._add_room(self._build_room(room_json))
		for hallway_to_add in level_json['hallways']:
			self._add_hallway(self._build_hallway(hallway_to_add))
		self._finalize_level()
	

	def _add_room(self, room_to_add):
		"""
		Add a room to the Snarl level. Room must not overlap with any current rooms or hallways.

		Parameters
        ----------
        room_to_add : room
            A properly formed room to add to the level
		"""
		# Ensure room does not overlap with any current rooms or hallways
		self._check_overlaps(room_to_add.get_tiles())

		self._update_maxes(room_to_add.get_row() + room_to_add.get_height(),
			room_to_add.get_col() + room_to_add.get_width())

		self._rooms.append(room_to_add)

	def _build_room(self, room_json):
		board = []
		tile_map = {0: 'X', 1: 'O', 2: '|'}
		# Convert the layout to a mapped list of strings
		for row_ind in range(len(room_json['layout'])):
			row = ""
			for col_ind in range(len(room_json['layout'][row_ind])):
				row += str(room_json['layout'][row_ind][col_ind])
			board.append(row)

		# Generate a room from the layout and the given origin
		new_room = Room(room_json['origin'][0], room_json['origin'][1], board)
		return new_room

	def _add_hallway(self, hallway_to_add):
		"""
		Add a hallway to the Snarl level. Hallway must not overlap with any current rooms or hallways.

		Parameters
        ----------
        hallway_to_add : hallway
            A properly formed hallway to add to the level. The end points of the hallway must both
            fall on the boundary of a room that has already been added.
		"""
		start_room = None
		end_room = None
		for room in self._rooms:
			if room.is_on_boundary(hallway_to_add.get_start_pos()[0], hallway_to_add.get_start_pos()[1]):
				start_room = room
			elif room.is_on_boundary(hallway_to_add.get_end_pos()[0], hallway_to_add.get_end_pos()[1]):
				end_room = room

		if start_room is None or end_room is None:
			raise ValueError("Cannot add hallway, end points are not on boundaries of different rooms.")

		self._check_overlaps(hallway_to_add.get_tiles())

		self._update_maxes(hallway_to_add.get_max_height(), hallway_to_add.get_max_width())

		start_room.add_room_door(hallway_to_add.get_start_pos()[0], hallway_to_add.get_start_pos()[1])

		end_room.add_room_door(hallway_to_add.get_end_pos()[0], hallway_to_add.get_end_pos()[1])
		self._hallways.append(hallway_to_add)

	def _build_hallway(self, hallway_json):
		new_hall = Hallway((hallway_json['from'][0], hallway_json['from'][1]), 
			(hallway_json['to'][0], hallway_json['to'][1]), hallway_json['waypoints'])
		return new_hall

	def _finalize_level(self):
		"""
		Generates a nested list of tiles to represent the level based off the current rooms and
		hallways that have been added
		"""
		# Pre allocate space for all of the tiles with walls
		for row_ind in range(self._max_height):
			row = []
			for col_ind in range(self._max_width):
				row.append(Wall(row_ind, col_ind))
			self._whole_level.append(row)

		# Iterate over each of the rooms, adding their tiles to the map
		for room in self._rooms:
			tiles = room.get_tiles()
			for tile in tiles:
				self._whole_level[tile.get_row()][tile.get_col()] = tile

		# Iterate over each of the hallways, adding their tiles to the map
		for hallway in self._hallways:
			tiles = hallway.get_tiles()
			for tile in tiles:
				self._whole_level[tile.get_row()][tile.get_col()] = tile

	def _update_maxes(self, max_row, max_col):
		"""
		Update the the dimensions of the entire level if the added component extends
		beyond the current dimensions.

		Parameters
        ----------
        max_row : int
            The max row index of the room or hallway
        lowest_pt : int
            The max col index of the room or hallway
		"""
		if max_row > self._max_height:
			self._max_height = max_row
		if max_col > self._max_width:
			self._max_width = max_col
		

	def _check_overlaps(self, tiles_to_add):
		"""
		Check whether the list of tiles to add over laps with any previously added components

		Parameters
		----------
		tiles_to_add : List[Tile]
			List of tiles to be added to the level
		"""
		pos_to_add = [(tile.get_row(), tile.get_col()) for tile in tiles_to_add]
		for component in self._rooms + self._hallways:
			component_positions = [(tile.get_row(), tile.get_col()) for tile in component.get_tiles()]

			for pos in pos_to_add:
				if pos in component_positions:
					raise ValueError("Cannot add, overlaps with another hallway or room.")

	def get_whole_level(self):
		"""
		Retrieves all of the tiles in the level as a flat list

		Returns
		-------
		List[Tile]
			All of level tiles
		"""
		return self._whole_level

	def get_rooms(self):
		"""
		Retrieves all of the rooms in the level

		Returns
		-------
		List[Room]
			All of level rooms
		"""
		return self._rooms

	def get_hallways(self):
		"""
		Retrieves all of the hallways in the level

		Returns
		-------
		List[Room]
			All of level hallways
		"""
		return self._hallways



     





















